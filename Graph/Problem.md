 - [ ] 这里图的Graph模版类用来做什么
 - [ ] __回看的时候考虑为什么要这样设计挡墙数据结构很重要
 - [ ] 虚函数静态类型和实际类型又是什么(实际类型与指针和引用有关)
` 如果不是通过引用（或指针），而是以值传递方式（如 void report(Animal animal) ）将派生类对象传递给函数，会发生对象切片 。即派生类对象赋值给基类对象时，派生类特有的成员会被 “切掉”，只保留基类部分 ，此时再调用函数永远是调用基类版本 。`
 ```
 如果 getName() 不是虚函数（即去掉 Base 中的 virtual 关键字），则调用将根据引用 / 指针的静态类型解
 ```
 - [ ] 基类的虚函数用 virtual 声明后，派生类中重写的函数自动成为虚函数（无论是否显式添加 virtual）。因此：
```
加 virtual：语义上显式声明该函数是虚函数，可增强可读性。
不加 virtual：不影响多态行为，但可能隐藏潜在错误（如函数签名不匹配）。
```

- [ ] 为什么这里纯虚基类没有构造和析构
- [ ] 函数指针是动态绑定的
- [ ]  虚函数表隐藏指针
- [ ] 虚函数表是一个动态指针数组
- [ ] string_view 和 string
- [ ] C++为什么基类的引用和指针可以被派生类构造
```
派生类对象包含基类子对象 ，即派生类对象中嵌入了基类对象的所有成员（数据成员和成员函数，这里成员函数指非虚函数等 ）。
比如有基类Base和派生类Derived，Derived对象在内存布局上，开头部分就是Base类对象的内容，后面接着是Derived类自己新增的成员。
所以基类指针可以指向派生类对象中基类子对象的起始地址，进而访问基类部分的成员 ，这是指针能够指向派生类对象的内存层面基础 
派生类是对基类的扩展，它满足基类所定义的类型规范，并且具有更多特性。可以把派生类对象视为一种特殊的基类对象 。
```
- [ ] 需要注意的是，基类指针或引用指向派生类对象后，只能访问派生类对象中从基类继承来的成员（通过指针或引用直接访问 ），不能直接访问派生类特有的成员，若要访问需进行类型转换（如dynamic_cast ） ，且需确保类型转换安全 

- [ ] 接口类 接口类是一个没有成员变量的类，其中所有函数都是纯虚函数！当您想要定义派生类必须实现的功能时，接口非常有用，将派生类如何实现该功能的细节完全留给派生类。

- [ ] 虚基类

- [ ] 1111
```
    /**
     * @brief 并没有直接插入节点Vertex，传递一个Tv类型数据，用它构造一个Vertex对象
     *
     * @param v
     * @return Rank
     */
    Rank insert(const Tv &v) override
    {
        // 为各顶点预留一条潜在边，这里是为什么
        for (int i = 0; i < n; i++)
        {
            E[i].insert(nullptr);
        }
        n++;
        E.insert(Vector<Edge<Te> *>(n, n, (Edge<Te> *)nullptr));
        return V.insert(Vertex<Tv>(v));
    }
```
通过传递数据而非顶点对象插入节点，是一种以数据为中心的设计策略，其核心优势在于：
解耦接口：简化用户使用，分离数据构造与图管理逻辑。
内存安全：避免悬空引用，统一内存管理。
结构一致性：确保邻接表与顶点数据同步更新

- [ ] [图示领接矩阵接口](https://juejin.cn/post/7299354838931554319)通过图示来学习领接矩阵

- [ ] 图与树的层次遍历的思考
- [ ] 有向图需要考虑可达域的问题 BFS算法从单连通扩展到多联通域
- [ ] 通过时间标签构建一颗深度搜索树
- [ ] 图对相邻节点的选择 
```
firstNbr 和 nextNbr如在邻接矩阵中如何选择的
在邻接矩阵中是按数组顺序逆向选择 4 3 2 1 
利用队列和栈的辅助，实现点的选择没有什么困难
```
 - [ ] 这里图的Graph模版类用来做什么
 - [ ] __回看的时候考虑为什么要这样设计挡墙数据结构很重要__
 - [ ] 虚函数静态类型和实际类型又是什么(实际类型与指针和引用有关)
` 如果不是通过引用（或指针），而是以值传递方式（如 void report(Animal animal) ）将派生类对象传递给函数，会发生对象切片 。即派生类对象赋值给基类对象时，派生类特有的成员会被 “切掉”，只保留基类部分 ，此时再调用函数永远是调用基类版本 。`

 ```
 如果 getName() 不是虚函数（即去掉 Base 中的 virtual 关键字），则调用将根据引用 / 指针的静态类型解
 ```
 - [ ] 基类的虚函数用 virtual 声明后，派生类中重写的函数自动成为虚函数（无论是否显式添加 virtual）。因此：
```
加 virtual：语义上显式声明该函数是虚函数，可增强可读性。
不加 virtual：不影响多态行为，但可能隐藏潜在错误（如函数签名不匹配）。
```

- [ ] 为什么这里纯虚基类没有构造和析构
- [ ] 虚析构函数不同名，但仍算重写
- [ ] 类可以将析构函数声明为纯虚函数，但必须提供定义
- [ ] 虚函数表又是什么，构造函数没有虚函数与其有关
- [ ] 禁止 public 非虚析构函数

```mermaid
graph LR
    A[基类是否用于多态？] -->|是| B[public virtual 析构函数]
    A -->|否| C[protected 非virtual 析构函数]
```

__public virtual 析构函数:__
```
目标：安全支持多态，允许通过基类指针正确释放派生类对象。
口诀：“若基类有子类，析构函数必为虚”。
```
__protected 非虚析构函数：__
```
目标：禁止外界将基类作为多态接口使用，强制通过派生类管理对象生命周期。
典型场景：
基类是 “抽象基类”（包含纯虚函数，但析构函数需提供实现）。
基类是 “工具类”，仅作为派生类的成员被组合使用，而非通过继承多态使用。
```
- [ ] BFS树还有跨边 树边，树边来进行bfs生成树的标识

## 这样的邻接表数组包裹着一个链表 ##
```
typedef struct VNode
{
	VertexType data; //顶点信息
	ArcNode* firstarc; //指向第一个边结点
}VNode;

typedef struct
{
	VNode adjlist[MaxVertexNum]; //邻接表的头结点数组
	int vexnum, edgenum; //图中的顶点数和边数
}AdjGraph;
――――――――――――――――

```