 - [ ] 这里图的Graph模版类用来做什么
 - [ ] __回看的时候考虑为什么要这样设计挡墙数据结构很重要__
 - [ ] 虚函数静态类型和实际类型又是什么(实际类型与指针和引用有关)
` 如果不是通过引用（或指针），而是以值传递方式（如 void report(Animal animal) ）将派生类对象传递给函数，会发生对象切片 。即派生类对象赋值给基类对象时，派生类特有的成员会被 “切掉”，只保留基类部分 ，此时再调用函数永远是调用基类版本 。`

 ```
 如果 getName() 不是虚函数（即去掉 Base 中的 virtual 关键字），则调用将根据引用 / 指针的静态类型解
 ```
 - [ ] 基类的虚函数用 virtual 声明后，派生类中重写的函数自动成为虚函数（无论是否显式添加 virtual）。因此：
```
加 virtual：语义上显式声明该函数是虚函数，可增强可读性。
不加 virtual：不影响多态行为，但可能隐藏潜在错误（如函数签名不匹配）。
```

- [ ] 为什么这里纯虚基类没有构造和析构
- [ ] 虚析构函数不同名，但仍算重写
- [ ] 类可以将析构函数声明为纯虚函数，但必须提供定义
- [ ] 虚函数表又是什么，构造函数没有虚函数与其有关
- [ ] 禁止 public 非虚析构函数

```mermaid
graph LR
    A[基类是否用于多态？] -->|是| B[public virtual 析构函数]
    A -->|否| C[protected 非virtual 析构函数]
```

__public virtual 析构函数:__
```
目标：安全支持多态，允许通过基类指针正确释放派生类对象。
口诀：“若基类有子类，析构函数必为虚”。
```
__protected 非虚析构函数：__
```
目标：禁止外界将基类作为多态接口使用，强制通过派生类管理对象生命周期。
典型场景：
基类是 “抽象基类”（包含纯虚函数，但析构函数需提供实现）。
基类是 “工具类”，仅作为派生类的成员被组合使用，而非通过继承多态使用。
```
