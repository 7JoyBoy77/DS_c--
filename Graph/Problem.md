 - [ ] 这里图的Graph模版类用来做什么
 - [ ] __回看的时候考虑为什么要这样设计挡墙数据结构很重要
 - [ ] 虚函数静态类型和实际类型又是什么(实际类型与指针和引用有关)
` 如果不是通过引用（或指针），而是以值传递方式（如 void report(Animal animal) ）将派生类对象传递给函数，会发生对象切片 。即派生类对象赋值给基类对象时，派生类特有的成员会被 “切掉”，只保留基类部分 ，此时再调用函数永远是调用基类版本 。`
 ```
 如果 getName() 不是虚函数（即去掉 Base 中的 virtual 关键字），则调用将根据引用 / 指针的静态类型解
 ```
 - [ ] 基类的虚函数用 virtual 声明后，派生类中重写的函数自动成为虚函数（无论是否显式添加 virtual）。因此：
```
加 virtual：语义上显式声明该函数是虚函数，可增强可读性。
不加 virtual：不影响多态行为，但可能隐藏潜在错误（如函数签名不匹配）。
```

- [ ] 为什么这里纯虚基类没有构造和析构
- [ ] 函数指针是动态绑定的
- [ ]  虚函数表隐藏指针
- [ ] 虚函数表是一个动态指针数组
- [ ] string_view 和 string
- [ ] C++为什么基类的引用和指针可以被派生类构造
```
派生类对象包含基类子对象 ，即派生类对象中嵌入了基类对象的所有成员（数据成员和成员函数，这里成员函数指非虚函数等 ）。比如有基类Base和派生类Derived，Derived对象在内存布局上，开头部分就是Base类对象的内容，后面接着是Derived类自己新增的成员。所以基类指针可以指向派生类对象中基类子对象的起始地址，进而访问基类部分的成员 ，这是指针能够指向派生类对象的内存层面基础 
派生类是对基类的扩展，它满足基类所定义的类型规范，并且具有更多特性。可以把派生类对象视为一种特殊的基类对象 。
```
- [ ] 需要注意的是，基类指针或引用指向派生类对象后，只能访问派生类对象中从基类继承来的成员（通过指针或引用直接访问 ），不能直接访问派生类特有的成员，若要访问需进行类型转换（如dynamic_cast ） ，且需确保类型转换安全 

- [ ] 接口类 接口类是一个没有成员变量的类，其中所有函数都是纯虚函数！当您想要定义派生类必须实现的功能时，接口非常有用，将派生类如何实现该功能的细节完全留给派生类。

- [ ] 虚基类

- [ ] 1111
```
    /**
     * @brief 并没有直接插入节点Vertex，传递一个Tv类型数据，用它构造一个Vertex对象
     *
     * @param v
     * @return Rank
     */
    Rank insert(const Tv &v) override
    {
        // 为各顶点预留一条潜在边，这里是为什么
        for (int i = 0; i < n; i++)
        {
            E[i].insert(nullptr);
        }
        n++;
        E.insert(Vector<Edge<Te> *>(n, n, (Edge<Te> *)nullptr));
        return V.insert(Vertex<Tv>(v));
    }
```
通过传递数据而非顶点对象插入节点，是一种以数据为中心的设计策略，其核心优势在于：
解耦接口：简化用户使用，分离数据构造与图管理逻辑。
内存安全：避免悬空引用，统一内存管理。
结构一致性：确保邻接表与顶点数据同步更新

- [ ] [图示领接矩阵接口](https://juejin.cn/post/7299354838931554319)通过图示来学习领接矩阵

- [ ] 图与树的层次遍历的思考
- [ ] 有向图需要考虑可达域的问题 BFS算法从单连通扩展到多联通域
- [ ] 通过时间标签构建一颗深度搜索树