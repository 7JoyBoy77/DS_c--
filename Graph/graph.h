#pragma once
#include "../Queue/queue.h"
#include <limits>
using VStatus = enum { UNDISCOVERED,
                       DISCOVERED,
                       VISITED }; // 顶点状态
                                  /**
                                   * @brief 边在遍历树中所属的类型
                                   *
                                   */
using EType = enum { UNDETERMINED,
                     TREE,
                     CROSS,
                     FORWARD,
                     BACKWARD };

template <typename Tv, typename Te> // 顶点类型、边类型
class Graph
{ // 图Graph模板类
private:
    void reset()
    { // 所有顶点、边的辅助信息复位
        for (int v = 0; v < n; v++)
        { // 所有顶点的
            status(v) = UNDISCOVERED;
            dTime(v) = fTime(v) = -1; // 状态，时间标签
            parent(v) = -1;
            priority(v) = INT_MAX;      // （在遍历树中的）父节点，优先级数
            for (int u = 0; u < n; u++) // 所有边的
                if (exists(v, u))
                    type(v, u) = UNDETERMINED; // 类型
        }
    }
    /**
     * @brief 单连通分量搜索
     *
     */
    void BFS(int, int &);                  // （连通域）广度优先搜索算法
    void DFS(Rank, Rank &);                // （连通域）深度优先搜索算法
    void BCC(Rank, Rank &, Stack<Rank> &); // （连通域）基于DFS的双连通分量分解算法
    bool TSort(Rank, Rank &, Stack<Tv> *); // （连通域）基于DFS的拓扑排序算法
    template <typename PU>
    void PFS(Rank, PU); // （连通域）优先级搜索框架
protected:
    int n; // 顶点
    int e; // 边：这里约定，无向边均统一转化为方向互逆的一对有向边，从而将无向图视作有向图的特例
    // 边总数
public:
    Graph() = default;
    virtual ~Graph() = default;
    virtual Rank insert(Tv const &) = 0; // 插入顶点，返回编号
    virtual Tv remove(Rank) = 0;         // 删除顶点及其关联边，返回该顶点信息
    virtual Tv &vertex(Rank) = 0;        // 顶点的数据（该顶点的确存在）
    virtual Rank inDegree(Rank) = 0;     // 顶点的入度（该顶点的确存在）
    virtual Rank outDegree(Rank) = 0;    // 顶点的出度（该顶点的确存在）
    /**
     * @brief 查找首个邻接节点
     * @note 邻接节点怎么计算的，怎么判定的，如何去找到
     * @return Rank
     */
    virtual Rank firstNbr(Rank) = 0;
    /**
     * @brief 查找顶点 i 的邻接表中，索引小于 j 的最后一个邻接顶点
     *
     * @return Rank
     */
    virtual Rank nextNbr(Rank, Rank) = 0;
    /**
     *
     * @return VStatus& 引用传递修改值
     */
    virtual VStatus &status(Rank) = 0; // 顶点的状态
    virtual Rank &dTime(Rank) = 0;     // 顶点的时间标签dTime
    virtual Rank &fTime(Rank) = 0;     // 顶点的时间标签fTime
    virtual Rank &parent(Rank) = 0;    // 顶点在遍历树中的父亲
    virtual int &priority(Rank) = 0;   // 顶点在遍历树中的优先级数

    virtual bool exists(Rank, Rank) = 0;                  // 边(v, u)是否存在
    virtual void insert(Te const &, int, Rank, Rank) = 0; // 在两个顶点之间插入指定权重的边
    virtual Te remove(Rank, Rank) = 0;                    // 删除一对顶点之间的边，返回该边信息
    virtual EType &type(Rank, Rank) = 0;                  // 边的类型
    virtual Te &edge(Rank, Rank) = 0;                     // 边的数据（该边的确存在）
    virtual int &weight(Rank, Rank) = 0;                  // 边(v, u)的权重

    /**
     * @brief 全图广度优先搜索算法
     *
     */
    void bfs(Rank);

    void dfs(Rank);         // 深度优先搜索算法
    void bcc(Rank);         // 基于DFS的双连通分量分解算法
    Stack<Tv> *tSort(Rank); // 基于DFS的拓扑排序算法
    void prim(Rank);        // 最小支撑树Prim算法
    void dijkstra(Rank);    // 最短路径Dijkstra算法
    template <typename PU>
    void pfs(Rank, PU); // 优先级搜索框架
};

template <typename Tv>
struct Vertex
{
    Tv data;
    int inDegree, outDegree;
    VStatus status;
    // 时间标签
    int dTime, fTime;
    // 遍历树中的节点，优先级
    int parent, priority;
    Vertex(const Tv &d = (Tv)0);
    ~Vertex();
};
template <typename Te>
struct Edge
{
    Te data;
    int weight;
    EType type;
    Edge(const Te &d, int w);
    ~Edge();
};