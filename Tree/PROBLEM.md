- [ ] 二叉树的题太过理论，内容也是
- [ ] 前缀无歧义编码
- [ ] 根据不同应用需求，还可以针对节点的深度增设成员变量depth，或者针对以当前节点为根
的子树规模（该节点的后代数目）增设成员变量size。利用这些变量固然可以加速静态的查询
或搜索，但为保持这些变量的时效性，在所属二叉树发生结构性调整（比如节点的插入或删除）
之后，这些成员变量都要动态地更新。因此，究竟是否值得引入此类成员变量，必须权衡利弊。

- [ ] PFC编码树没看。
- [ ] 为什么定义类模板的函数需要在类名后加<T>
- [ ] 为什么要定义一个操作器` template<typename VST>
- [ ] 节点高度更新问题
- [ ] 节点类中左插右插节点相同
- [ ] 指针类型的引用 `BinTree<T> *&S ` 
- [ ] 插入子树这里问题还要深究，释放子树本身树资源，为什么要用指针类型的引用传递tree参数，而直接用引用
```
通常情况下，树对象（如 BinTree<T>）是通过动态内存分配（new）创建的，例如：
BinTree<int>* subTree = new BinTree<int>(); // 堆上创建子树
root->attachAsLC(subTree); // 接入子树
```
- [ ] 根据实际树的情况思考，就像是List和ListNode的区别  
- [ ] tree的release需要从树的构造开始考虑,node的release
- [ ] 尾递归优化消除 尾递归的核心是递归调用后无额外计算或操作 利用stack 模拟递归调用栈

- [ ] 完全二叉树和满二叉树 PFC解码和编码 huffman编码
- [ ] 使用. 和 *（）. 和 ->
- [ ] 如何理解树的递归性质
- [ ] 消除尾递归是什么
- [ ] VST体现了策略模式的思想 
- [ ] 函数指针类型模版 ` using VisitFuncPtr = void (*)(T)`
- [ ] 先序遍历右子树接近尾递归，所以代码上尾递归一般化的时候，一个循环就解决了，是这样吗？
- [ ] 中序遍历由于左子树不是尾递归，实现难点就在这里
- [ ] 对象组合和对象关系是什么
- [ ] 为什么构造用public，继承类可以使用基类构造
- [ ] 何时应该使用protected访问说明符?
```
在基类中具有protected的成员时，派生类可以直接访问该成员。这意味着，如果以后更改有关protected的任何内容（类型、值的含义等），则可能需要同时更改基类和所有派生类。

当您（或您的团队）从自己的类中派生，并且派生类的数量是合理的时，使用protected访问说明符是可以的。如果您对基类的实现进行了更改，并且因此需要更新派生类，则可以自己进行更新（并且派生类的数量是有限的）。
```
- [ ]使用指向基类的指针和引用
- [ ] 运行时多态，虚函数解析
- [ ] 二叉树递归变迭代，这样转换，和如何转换的算法思想是怎样的，需要了解递归的一般性消除吗？
```
递归隐式依赖系统栈：自动保存右子树的处理任务，按 “根→左→右” 顺序执行。
迭代显式使用用户栈：手动压入右子节点，优先处理左子树，保证顺序一致。
```
### 在先序遍历从递归转换为迭代的过程中，模拟左子树优先遍历的逻辑主要通过 ** 栈（Stack）** 来实现，核心思想是利用栈保存后续需要访问的右子树节点，从而优先处理左子树 其本质是通过系统栈隐式保存遍历路径：处理完当前节点后，先进入左子树递归，右子树的处理被 “暂存” 在递归栈中，待左子树处理完毕后再执行###
### 栈的使用好像就是如此 ， 实际应用场景可以用栈解决###

- [ ] new 类对象时，内存分配 内存对齐机制
```
sizeof(*obj) 测量的是 obj 指针所指向的对象（即 Mem 类的实例）的大小。
Mem 类包含一个 double（通常 8 字节）和一个 int（通常 4 字节）。
由于内存对齐要求（假设按 8 字节对齐），int 后面会填充 4 字节，因此 Mem 的总大小为 16 字节
sizeof(obj) 测量的是指针本身的大小。
在 32 位系统上，指针大小为 4 字节；在 64 位系统上，指针大小为 8 字节。
因此，输出通常为 8 字节（假设你使用的是 64 位系统）
class Mem
{
private:
    double a;
    int b;
};
int main()
{
    Mem *obj = new Mem();
    std::cout << sizeof(*(obj)) << std::endl;
    return 0;
}
```

- [ ] 节点高度更新算法

- [ ] 
```
当前代码中，remove 函数已经通过 fromParent(*bn) = nullptr 将父节点指向该节点的指针（左或右子节点）置空，避免了父节点的子指针成为悬空指针。但外部用户持有的节点指针（如用户自己保存的 BinNode<T>* 变量）未被处理，这部分需要额外处理。

template <typename T>
BinNode<T> *BinNode<T>::insertAsLeft(const T &e)
{
    BinNode<T> *bn = new BinNode(e, this);
    this->left = bn;
    return bn;
}
int BinTree<T>::removeAt(BinNode<T> *bn)
{
    if (!bn)
    {
        return 0;
    }
    int n = 1 + removeAt(bn->left) + removeAt(bn->right);
    delete bn;
    return n;
    // release(bn.data); release(bn); return n;
}
```