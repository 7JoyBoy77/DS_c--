- [ ] 二叉树的题太过理论，内容也是
- [ ] 前缀无歧义编码
- [ ] 根据不同应用需求，还可以针对节点的深度增设成员变量depth，或者针对以当前节点为根
的子树规模（该节点的后代数目）增设成员变量size。利用这些变量固然可以加速静态的查询
或搜索，但为保持这些变量的时效性，在所属二叉树发生结构性调整（比如节点的插入或删除）
之后，这些成员变量都要动态地更新。因此，究竟是否值得引入此类成员变量，必须权衡利弊。

- [ ] PFC编码树没看。
- [ ] 为什么定义类模板的函数需要在类名后加<T>
- [ ] 为什么要定义一个操作器` template<typename VST>
- [ ] 节点高度更新问题
- [ ] 节点类中左插右插节点相同
- [ ] 指针类型的引用 `BinTree<T> *&S ` 
- [ ] 插入子树这里问题还要深究，释放子树本身树资源，为什么要用指针类型的引用传递tree参数，而直接用引用
```
通常情况下，树对象（如 BinTree<T>）是通过动态内存分配（new）创建的，例如：
BinTree<int>* subTree = new BinTree<int>(); // 堆上创建子树
root->attachAsLC(subTree); // 接入子树
```
- [ ] 根据实际树的情况思考，就像是List和ListNode的区别  
- [ ] tree的release需要从树的构造开始考虑,node的release
- [ ] 尾递归优化消除 尾递归的核心是递归调用后无额外计算或操作 利用stack 模拟递归调用栈

- [ ] 完全二叉树和满二叉树 PFC解码和编码 huffman编码
- [ ] 使用. 和 *（）. 和 ->
- [ ] 如何理解树的递归性质
- [ ] 消除尾递归是什么
- [ ] VST体现了策略模式的思想 
- [ ] 函数指针类型模版 ` using VisitFuncPtr = void (*)(T)`