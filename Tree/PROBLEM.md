- [ ] 二叉树的题太过理论，内容也是
- [ ] 前缀无歧义编码
- [ ] 根据不同应用需求，还可以针对节点的深度增设成员变量depth，或者针对以当前节点为根
的子树规模（该节点的后代数目）增设成员变量size。利用这些变量固然可以加速静态的查询
或搜索，但为保持这些变量的时效性，在所属二叉树发生结构性调整（比如节点的插入或删除）
之后，这些成员变量都要动态地更新。因此，究竟是否值得引入此类成员变量，必须权衡利弊。

- [ ] PFC编码树没看。
- [ ] 为什么定义类模板的函数需要在类名后加<T>
` 在 C++ 中，类模板的成员函数需要在类名后加上 <T> 是因为这些函数是模板函数，它们的实现依赖于模板参数 T。这种语法明确告诉编译器：这个函数属于类模板，并且使用与类相同的模板参数`
- [ ] 为什么要定义一个操作器` template<typename VST>
- [x] 节点高度更新问题
- [x] 节点类中左插右插节点相同
- [ ] 指针类型的引用 `BinTree<T> *&S ` 
- [x] 插入子树这里问题还要深究，释放子树本身树资源，为什么要用指针类型的引用传递tree参数，而直接用引用
` 引用是为了不让传入一个副本，而是传入原来的指针BinTree<T> *的指针  传入指针的目的是为了释放指向的空间 也就是传入的树的空间 ， 并没有释放 S 指向的节点空间（节点已被合并到当前树中）原树容器（BinTree<T> 对象）的所有权：原树 S 作为一个独立的树容器（管理节点的元数据，如 _root、_size 等）已不再需要，需手动释放其自身的堆内存。`
__假设原树 S 是通过 new 在堆上创建的（如 BinTree<T> *S = new BinTree<T>我们需要手动释放内存, 这里是内存释放问题，手动管理非常复杂，利用 std::unique_ptr 或 std::shared_ptr 自动管理堆对象的生命周期，减少手动 delete 的需求。__
__C++ 主要通过 RAII（资源获取即初始化）机制 和 智能指针（Smart Pointers） 解决动态内存管理问题，特别是对象生命周期与资源释放的绑定问题__
`BinTree 类的成员变量 _root 是指向动态分配的 BinNode<T> 节点的指针（通过 new 创建，如 insertRoot 函数中 new BinNode(e)）。默认析构函数仅会销毁 _root 指针本身（栈上的指针变量），但不会释放 _root 指向的堆内存（即树中所有节点的内存）`
- [ ] 此处通过释放传入树的空间与之前释放节点的空间思考 
` bn 在插入时被new出来分配到堆， 在删除相关节点时，需要释放其节点内存，需要delete，那么这里接入子树时，在释放原树BinTree<T> *的指针需要怎么做`
```
BinNode<T> *BinTree<T>::attachAsLeft(BinNode<T> *x, BinTree<T> *&S)
{
    if ((x->left = S->_root) != nullptr)
    {
        S->_root->parent = x;
    }
    _size += S->_size;
    updateHeightAbove(x);
    S->_root = nullptr;
    S->_size = 0;
    // release(S);
    S = nullptr;
    return x->left;
    // 释放树之后，节点不会被释放，只不过，链接过来的S树的节点，被现在的树控制。
    // 之前的树释放，然后就没有控制之前树节点的树了。释放树没有释放节点。
    // Answer
    /**
     * @note
     * 根据 BinTree 类的设计，
     * release 函数的核心功能是断开原树 S 与节点的关联，而非删除节点。
     */
}
```
```
通常情况下，树对象（如 BinTree<T>）是通过动态内存分配（new）创建的，例如：
BinTree<int>* subTree = new BinTree<int>(); // 堆上创建子树
root->attachAsLC(subTree); // 接入子树
```
- [x] 根据实际树的情况思考，就像是List和ListNode的区别  
- [x] tree的release需要从树的构造开始考虑,node的release
- [ ] 尾递归优化消除 尾递归的核心是递归调用后无额外计算或操作 利用stack 模拟递归调用栈
` 尾递归消除是因为最后如果还有操作的话，栈压入操作，会第一时间弹出，并不能最后执行，所以在后序遍历中，将访问根节点的操作在最后时间进行，便可以将递归形式的二叉树转换为迭代的版本，这对吗`

- [ ] 完全二叉树和满二叉树 PFC解码和编码 huffman编码
- [ ] 使用. 和 *（）. 和 ->
- [ ] 如何理解树的递归性质
- [ ] 消除尾递归是什么
- [ ] VST体现了策略模式的思想 
- [ ] 函数指针类型模版 ` using VisitFuncPtr = void (*)(T)`
- [ ] 先序遍历右子树接近尾递归，所以代码上尾递归一般化的时候，一个循环就解决了，是这样吗？
- [ ] 中序遍历由于左子树不是尾递归，实现难点就在这里
- [ ] 对象组合和对象关系是什么
- [ ] 为什么构造用public，继承类可以使用基类构造
- [ ] 何时应该使用protected访问说明符?
```
在基类中具有protected的成员时，派生类可以直接访问该成员。这意味着，如果以后更改有关protected的任何内容（类型、值的含义等），则可能需要同时更改基类和所有派生类。

当您（或您的团队）从自己的类中派生，并且派生类的数量是合理的时，使用protected访问说明符是可以的。如果您对基类的实现进行了更改，并且因此需要更新派生类，则可以自己进行更新（并且派生类的数量是有限的）。
```
- [ ]使用指向基类的指针和引用
- [ ] 运行时多态，虚函数解析
- [ ] 二叉树递归变迭代，这样转换，和如何转换的算法思想是怎样的，需要了解递归的一般性消除吗？
```
递归隐式依赖系统栈：自动保存右子树的处理任务，按 “根→左→右” 顺序执行。
迭代显式使用用户栈：手动压入右子节点，优先处理左子树，保证顺序一致。
```
### 在先序遍历从递归转换为迭代的过程中，模拟左子树优先遍历的逻辑主要通过 ** 栈（Stack）** 来实现，核心思想是利用栈保存后续需要访问的右子树节点，从而优先处理左子树 其本质是通过系统栈隐式保存遍历路径：处理完当前节点后，先进入左子树递归，右子树的处理被 “暂存” 在递归栈中，待左子树处理完毕后再执行###
### 栈的使用好像就是如此 ， 实际应用场景可以用栈解决###

- [ ] new 类对象时，内存分配 内存对齐机制
```
sizeof(*obj) 测量的是 obj 指针所指向的对象（即 Mem 类的实例）的大小。
Mem 类包含一个 double（通常 8 字节）和一个 int（通常 4 字节）。
由于内存对齐要求（假设按 8 字节对齐），int 后面会填充 4 字节，因此 Mem 的总大小为 16 字节
sizeof(obj) 测量的是指针本身的大小。
在 32 位系统上，指针大小为 4 字节；在 64 位系统上，指针大小为 8 字节。
因此，输出通常为 8 字节（假设你使用的是 64 位系统）
class Mem
{
private:
    double a;
    int b;
};
int main()
{
    Mem *obj = new Mem();
    std::cout << sizeof(*(obj)) << std::endl;
    return 0;
}
```

- [ ] 节点高度更新算法

- [ ] 
```
当前代码中，remove 函数已经通过 fromParent(*bn) = nullptr 将父节点指向该节点的指针（左或右子节点）置空，避免了父节点的子指针成为悬空指针。但外部用户持有的节点指针（如用户自己保存的 BinNode<T>* 变量）未被处理，这部分需要额外处理。

template <typename T>
BinNode<T> *BinNode<T>::insertAsLeft(const T &e)
{
    BinNode<T> *bn = new BinNode(e, this);
    this->left = bn;
    return bn;
}
int BinTree<T>::removeAt(BinNode<T> *bn)
{
    if (!bn)
    {
        return 0;
    }
    int n = 1 + removeAt(bn->left) + removeAt(bn->right);
    delete bn;
    return n;
    // release(bn.data); release(bn); return n;
}
```

- [ ] 递归可以用数学归纳法完全证明
- [ ] 递归确实很容易看出来逻辑，但是如何转换迭代需要思考    