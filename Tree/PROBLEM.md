- [ ] 二叉树的题太过理论，内容也是
- [ ] 前缀无歧义编码
- [ ] 根据不同应用需求，还可以针对节点的深度增设成员变量depth，或者针对以当前节点为根
的子树规模（该节点的后代数目）增设成员变量size。利用这些变量固然可以加速静态的查询
或搜索，但为保持这些变量的时效性，在所属二叉树发生结构性调整（比如节点的插入或删除）
之后，这些成员变量都要动态地更新。因此，究竟是否值得引入此类成员变量，必须权衡利弊。

- [ ] PFC编码树没看。
- [ ] 为什么定义类模板的函数需要在类名后加<T>
- [ ] 为什么要定义一个操作器` template<typename VST>
- [ ] 节点高度更新问题
- [ ] 节点类中左插右插节点相同
- [ ] 指针类型的引用 `BinTree<T> *&S ` 
- [ ] 插入子树这里问题还要深究，释放子树本身树资源，为什么要用指针类型的引用传递tree参数，而直接用引用
```
通常情况下，树对象（如 BinTree<T>）是通过动态内存分配（new）创建的，例如：
BinTree<int>* subTree = new BinTree<int>(); // 堆上创建子树
root->attachAsLC(subTree); // 接入子树
```
- [ ] 根据实际树的情况思考，就像是List和ListNode的区别  
- [ ] tree的release需要从树的构造开始考虑,node的release
- [ ] 尾递归优化消除 尾递归的核心是递归调用后无额外计算或操作 利用stack 模拟递归调用栈

- [ ] 完全二叉树和满二叉树 PFC解码和编码 huffman编码
- [ ] 使用. 和 *（）. 和 ->
- [ ] 如何理解树的递归性质
- [ ] 消除尾递归是什么
- [ ] VST体现了策略模式的思想 
- [ ] 函数指针类型模版 ` using VisitFuncPtr = void (*)(T)`
- [ ] 先序遍历右子树接近尾递归，所以代码上尾递归一般化的时候，一个循环就解决了，是这样吗？
- [ ] 中序遍历由于左子树不是尾递归，实现难点就在这里
- [ ] 对象组合和对象关系是什么
- [ ] 为什么构造用public，继承类可以使用基类构造
- [ ] 何时应该使用protected访问说明符?
```
在基类中具有protected的成员时，派生类可以直接访问该成员。这意味着，如果以后更改有关protected的任何内容（类型、值的含义等），则可能需要同时更改基类和所有派生类。

当您（或您的团队）从自己的类中派生，并且派生类的数量是合理的时，使用protected访问说明符是可以的。如果您对基类的实现进行了更改，并且因此需要更新派生类，则可以自己进行更新（并且派生类的数量是有限的）。
```
- [ ]使用指向基类的指针和引用
- [ ] 运行时多态，虚函数解析
- [ ] 二叉树递归变迭代，这样转换，和如何转换的算法思想是怎样的，需要了解递归的一般性消除吗？
```
递归隐式依赖系统栈：自动保存右子树的处理任务，按 “根→左→右” 顺序执行。
迭代显式使用用户栈：手动压入右子节点，优先处理左子树，保证顺序一致。
```
### 在先序遍历从递归转换为迭代的过程中，模拟左子树优先遍历的逻辑主要通过 ** 栈（Stack）** 来实现，核心思想是利用栈保存后续需要访问的右子树节点，从而优先处理左子树 其本质是通过系统栈隐式保存遍历路径：处理完当前节点后，先进入左子树递归，右子树的处理被 “暂存” 在递归栈中，待左子树处理完毕后再执行###
### 栈的使用好像就是如此 ， 实际应用场景可以用栈解决###
