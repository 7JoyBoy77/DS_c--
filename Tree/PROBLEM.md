- [ ] 二叉树的题太过理论，内容也是
- [ ] 前缀无歧义编码
- [ ] 根据不同应用需求，还可以针对节点的深度增设成员变量depth，或者针对以当前节点为根
的子树规模（该节点的后代数目）增设成员变量size。利用这些变量固然可以加速静态的查询
或搜索，但为保持这些变量的时效性，在所属二叉树发生结构性调整（比如节点的插入或删除）
之后，这些成员变量都要动态地更新。因此，究竟是否值得引入此类成员变量，必须权衡利弊。

- [ ] PFC编码树没看。
- [ ] 为什么定义类模板的函数需要在类名后加<T>
` 在 C++ 中，类模板的成员函数需要在类名后加上 <T> 是因为这些函数是模板函数，它们的实现依赖于模板参数 T。这种语法明确告诉编译器：这个函数属于类模板，并且使用与类相同的模板参数`
- [ ] 为什么要定义一个操作器` template<typename VST>
- [x] 节点高度更新问题
- [x] 节点类中左插右插节点相同
- [ ] 指针类型的引用 `BinTree<T> *&S ` 
- [x] 插入子树这里问题还要深究，释放子树本身树资源，为什么要用指针类型的引用传递tree参数，而直接用引用
` 引用是为了不让传入一个副本，而是传入原来的指针BinTree<T> *的指针  传入指针的目的是为了释放指向的空间 也就是传入的树的空间 ， 并没有释放 S 指向的节点空间（节点已被合并到当前树中）原树容器（BinTree<T> 对象）的所有权：原树 S 作为一个独立的树容器（管理节点的元数据，如 _root、_size 等）已不再需要，需手动释放其自身的堆内存。`
__假设原树 S 是通过 new 在堆上创建的（如 BinTree<T> *S = new BinTree<T>我们需要手动释放内存, 这里是内存释放问题，手动管理非常复杂，利用 std::unique_ptr 或 std::shared_ptr 自动管理堆对象的生命周期，减少手动 delete 的需求。__
__C++ 主要通过 RAII（资源获取即初始化）机制 和 智能指针（Smart Pointers） 解决动态内存管理问题，特别是对象生命周期与资源释放的绑定问题__
`BinTree 类的成员变量 _root 是指向动态分配的 BinNode<T> 节点的指针（通过 new 创建，如 insertRoot 函数中 new BinNode(e)）。默认析构函数仅会销毁 _root 指针本身（栈上的指针变量），但不会释放 _root 指向的堆内存（即树中所有节点的内存）`
- [ ] 此处通过释放传入树的空间与之前释放节点的空间思考 
` bn 在插入时被new出来分配到堆， 在删除相关节点时，需要释放其节点内存，需要delete，那么这里接入子树时，在释放原树BinTree<T> *的指针需要怎么做`
`类的最好之处之一是它们包含析构函数，当类的对象超出作用域时，析构函数会自动执行。因此，如果在构造函数中分配（或获取）内存，则可以在析构函数中释放它，并确保在类对象被销毁时释放内存（无论它是否超出作用域、是否显式删除，等等…）。这是RAII编程范例的核心。`

- [ ] 智能指针是一个组合类，旨在管理动态分配的内存，并确保当智能指针对象超出作用域时删除内存。
```
#include <iostream>

template <typename T>
class Auto_ptr1
{
	T* m_ptr {};
public:
	// 通过构造函数，“拥有”传递进来的指针
	Auto_ptr1(T* ptr=nullptr)
		:m_ptr(ptr)
	{
	}
	
	// 析构函数，确保拥有的指针被释放
	~Auto_ptr1()
	{
		delete m_ptr;
	}

	// 重载 解引用 和 operator-> ，以便 Auto_ptr1 用起来和 m_ptr 姿势一样.
	T& operator*() const { return *m_ptr; }
	T* operator->() const { return m_ptr; }
};

// 样例class，用来证明上述的方案有效
class Resource
{
public:
    Resource() { std::cout << "Resource acquired\n"; }
    ~Resource() { std::cout << "Resource destroyed\n"; }
};

int main()
{
	Auto_ptr1<Resource> res(new Resource()); // 注意这里动态分配了内存

        // ... 但没有显式delete释放

	// 注意这里使用 <Resource>, 而不是 <Resource*>
        // 这是因为 m_ptr 的类型时 T* (而不是 T)

	return 0;
}
```
```
BinNode<T> *BinTree<T>::attachAsLeft(BinNode<T> *x, BinTree<T> *&S)
{
    if ((x->left = S->_root) != nullptr)
    {
        S->_root->parent = x;
    }
    _size += S->_size;
    updateHeightAbove(x);
    S->_root = nullptr;
    S->_size = 0;
    // release(S);
    S = nullptr;
    return x->left;
    // 释放树之后，节点不会被释放，只不过，链接过来的S树的节点，被现在的树控制。
    // 之前的树释放，然后就没有控制之前树节点的树了。释放树没有释放节点。
    // Answer
    /**
     * @note
     * 根据 BinTree 类的设计，
     * release 函数的核心功能是断开原树 S 与节点的关联，而非删除节点。
     */
}
```
```
通常情况下，树对象（如 BinTree<T>）是通过动态内存分配（new）创建的，例如：
BinTree<int>* subTree = new BinTree<int>(); // 堆上创建子树
root->attachAsLC(subTree); // 接入子树
```
- [x] 根据实际树的情况思考，就像是List和ListNode的区别  
- [x] tree的release需要从树的构造开始考虑,node的release
- [ ] 尾递归优化消除 尾递归的核心是递归调用后无额外计算或操作 利用stack 模拟递归调用栈
` 尾递归消除是因为最后如果还有操作的话，栈压入操作，会第一时间弹出，并不能最后执行，所以在后序遍历中，将访问根节点的操作在最后时间进行，便可以将递归形式的二叉树转换为迭代的版本，这对吗`

- [ ] 完全二叉树和满二叉树 PFC解码和编码 huffman编码
- [ ] 使用. 和 *（）. 和 ->
- [ ] 如何理解树的递归性质
- [ ] 消除尾递归是什么
- [ ] VST体现了策略模式的思想 
- [ ] 函数指针类型模版 ` using VisitFuncPtr = void (*)(T)`
- [ ] 先序遍历右子树接近尾递归，所以代码上尾递归一般化的时候，一个循环就解决了，是这样吗？
- [ ] 中序遍历由于左子树不是尾递归，实现难点就在这里
- [ ] 对象组合和对象关系是什么
- [ ] 为什么构造用public，继承类可以使用基类构造
- [ ] 何时应该使用protected访问说明符?
```
在基类中具有protected的成员时，派生类可以直接访问该成员。这意味着，如果以后更改有关protected的任何内容（类型、值的含义等），则可能需要同时更改基类和所有派生类。

当您（或您的团队）从自己的类中派生，并且派生类的数量是合理的时，使用protected访问说明符是可以的。如果您对基类的实现进行了更改，并且因此需要更新派生类，则可以自己进行更新（并且派生类的数量是有限的）。
```
- [ ]使用指向基类的指针和引用
- [ ] 运行时多态，虚函数解析
- [ ] 二叉树递归变迭代，这样转换，和如何转换的算法思想是怎样的，需要了解递归的一般性消除吗？
```
递归隐式依赖系统栈：自动保存右子树的处理任务，按 “根→左→右” 顺序执行。
在这行代码中，函数在递归调用后没有其他代码需要执行（即没有需要等待子调用结果再计算的步骤）。因此，当前栈帧的以下信息不再需要保留：
    `return tail_factorial(n - 1, n * acc)`

局部变量（如 n 和 acc，因为新的递归调用的参数 n-1 和 n*acc 已包含了后续计算所需的全部信息）；
返回地址（因为函数执行到递归调用后就结束了，无需回到当前栈帧的其他位置）；
未完成的计算步骤（无后续操作）。

迭代显式使用用户栈：手动压入右子节点，优先处理左子树，保证顺序一致。
```
### 在先序遍历从递归转换为迭代的过程中，模拟左子树优先遍历的逻辑主要通过 ** 栈（Stack）** 来实现，核心思想是利用栈保存后续需要访问的右子树节点，从而优先处理左子树 其本质是通过系统栈隐式保存遍历路径：处理完当前节点后，先进入左子树递归，右子树的处理被 “暂存” 在递归栈中，待左子树处理完毕后再执行###
### 栈的使用好像就是如此 ， 实际应用场景可以用栈解决###

- [ ] new 类对象时，内存分配 内存对齐机制
```
sizeof(*obj) 测量的是 obj 指针所指向的对象（即 Mem 类的实例）的大小。
Mem 类包含一个 double（通常 8 字节）和一个 int（通常 4 字节）。
由于内存对齐要求（假设按 8 字节对齐），int 后面会填充 4 字节，因此 Mem 的总大小为 16 字节
sizeof(obj) 测量的是指针本身的大小。
在 32 位系统上，指针大小为 4 字节；在 64 位系统上，指针大小为 8 字节。
因此，输出通常为 8 字节（假设你使用的是 64 位系统）
class Mem
{
private:
    double a;
    int b;
};
int main()
{
    Mem *obj = new Mem();
    std::cout << sizeof(*(obj)) << std::endl;
    return 0;
}
```

- [ ] 节点高度更新算法
` Leetcode算法题中，树的结构不同，通过BFS，DFS来遍历`
- [ ] 
```
当前代码中，remove 函数已经通过 fromParent(*bn) = nullptr 将父节点指向该节点的指针（左或右子节点）置空，避免了父节点的子指针成为悬空指针。但外部用户持有的节点指针（如用户自己保存的 BinNode<T>* 变量）未被处理，这部分需要额外处理。

template <typename T>
BinNode<T> *BinNode<T>::insertAsLeft(const T &e)
{
    BinNode<T> *bn = new BinNode(e, this);
    this->left = bn;
    return bn;
}
int BinTree<T>::removeAt(BinNode<T> *bn)
{
    if (!bn)
    {
        return 0;
    }
    int n = 1 + removeAt(bn->left) + removeAt(bn->right);
    delete bn;
    return n;
    // release(bn.data); release(bn); return n;
}
```

- [ ] 递归可以用数学归纳法完全证明
- [ ] 递归确实很容易看出来逻辑，但是如何转换迭代需要思考    